= {product} Design Document
Giorgio Azzinnaro <giorgio@azzinna.ro>
v0.1, 2020-11-07
:toc:
:homepage: https://github.com/giorgioazzinnaro/farmfa
:product: farMFA

== Overview

{product} is a tool to improve the security of shared accounts protected by a TOTP <<RFC6238>>.
By splitting and distributing the secret among _n_ individuals -- via Shamir's Secret Sharing <<SSS>> --
the one-time password can only be generated by reconstructing the secret (with at least _t_ shares).
Because {product} oracle generates and returns only the current one-time password,
the users do not risk leaking the secret.

== What problem does {product} solve?

{product} comes into play in enterprise environments, where access to certain accounts should be restricted.
Even with a proper Single Sign-On implementation, there are some exceptional cases where accounts are not nominal,
and need to be shared by multiple administrators.
Said accounts are also rather often particularly sensitive, and thus deserve multiple authentication factors.
While most teams already have a password manager, storing the TOTP secret in it defeats the purpose of MFA:
for increased security, it should be stored separately.

== Concept

{product} is composed of a oracle that reconstructs TOTP secrets, and generates the corresponding one-time password.
Users are conceptually divided between dealers (1 per session) and players (at least _t_ for each secret).
When a dealer needs access to a certain TOTP, they start a session, and ask players to join, by sharing their own Tocs.
As soon as _t_ players have shared their Toc -- with {product} oracle, rather than the player directly --
the player may ask the oracle to reconstruct the TOTP secret, and generate a one-time password.
Because of this, the dealer will never receive the entire TOTP secret, hence they won't be able to generate
further one-time passwords, after their session ends.

== Design

=== TOTP secret splitting and Tocs generation

For any TOTP secret, the first step is for the dealer to split it, encrypt the resulting Tocs, and share them.
While the oracle MAY implement this functionality, it is RECOMMENDED this process is executed client-side.
This is the most vulnerable process as the dealer could accidentally leak the TOTP secret,
essentially voiding any further security measure taken afterwards.
At this initial step, the dealer decides how many players will receive a Toc (_n_),
and how many of them are required, to be able to reconstruct it (_t_). With stem:[t <= n].
Additionally, the player SHOULD define an encryption strategy for each recipient.

=== Starting a new session

When a dealer needs to access an account, and thus needs to generate the corresponding TOTP, they start a session.
A session is represented by an identifier (that of the group of Tocs), a public key, and a private key
(that is in part shared with the dealer, and in part kept by the oracle).
With this information, the dealer can ask _n_ players to join the session.
More precisely, they share the public key, and the identifier.

=== Combining Tocs and generating one-time passwords

A dealer asks a player to join a session, and authorise them to generate a TOTP.
To identify the session, the dealer sends an identifier (that uniquely identifies the group of Tocs),
and a public key, that is unique to the current session.
The player will fetch their Toc based on the identifier, encrypt it with the public key, and send it to the oracle.

=== Flows
[plantuml]
....
actor     dealer as d
boundary  oracle as o
actor     "player 1" as p1
actor     "player 2" as p2

d -> d:   Split(Secret, PublicKeys) = [{Toc<sub>1</sub>}<sub>K1</sub> .. {Toc<sub>n</sub>}<sub>Kn</sub>]

d -> p1:  Send {Toc<sub>1</sub>}<sub>K1</sub>
d -> p2:  Send {Toc<sub>2</sub>}<sub>K2</sub>

note left
Each player receives
a //Toc// encrypted
with their public key.
end note

...

d -> o:   CreateSession(SecretID)
return    SessionKeypair

note right
In a SessionKeypair are
a private key, a public key,
and a secret identifier
end note

d  -> p1:  session identifier (public key + Toc identifier)
d  -> p2:  session identifier (public key + Toc identifier)
p1 -> o:   Toc encrypted with session public key
p2 -> o:   Toc encrypted with session public key

d  -> o:   request TOTP (private key)
o -> o:   decrypt each Toc with private key
return     return one-time password
....

[bibliography]
== References

- [[[RFC6238]]] M'Raihi, D., Machani, S., Pei, M., and J. Rydell, "TOTP: Time-Based One-Time Password Algorithm",
                RFC 6238, DOI 10.17487/RFC6238, May 2011, <https://www.rfc-editor.org/info/rfc6238>.
- [[[SSS,2]]] Adi Shamir. 1979. How to share a secret. Commun. ACM 22, 11 (Nov. 1979), 612â€“613.
            DOI:https://doi.org/10.1145/359168.359176

== Glossary

// TODO Should have different terms for the user that creates the Tocs and that who starts sessions and generates TOTPs
dealer:: Creates Tocs and manages sessions to generate TOTPs

oracle:: The entity that reconstructs Tocs into TOTP secrets, and generates one-time passwords.

player:: The individuals who join a session to authorise a dealer to generate a TOTP, by reaching a quorum/threshold.

recipient:: During the Tocs creation phase, the individuals who each receive one of said Tocs

secret:: A TOTP is a hash generated from a secret.
         This secret is usually shown as a QR code and shared between the prover and verifier.
         In {product}, the prover becomes a distributed entity: recipients who share the key material,
         and an oracle that actually generates the TOTP.

server:: In our context synonym with _oracle_.

session:: Describes the workflow in which a dealer requires combining Tocs to generate a TOTP

Toc:: The "pieces" in which a TOTP secret gets split

TOTP:: As defined in <<RFC6238>>:
       "an extension of the One-Time Password (OTP) algorithm [...] to support the time-based moving factor".
       Used by many applications as a second authentication factor.
